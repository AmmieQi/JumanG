% Juneki Hong and Michael Tango
% Declarative Methods
% Professor Eisner
% May 3, 2013


\documentclass{article}
\usepackage{acl2012}
\usepackage{times}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{url}
\setlength\titlebox{6.5cm}    % Expanding the titlebox


\title{Declarative Methods Term Project: \\ JumanG}
\author{Juneki Hong and Michael Tango}

%\usepackage[ampersand]{easylist}

\date{}
\begin{document}
\maketitle

\begin{abstract}
In this paper, we attempt to display graphs in an effective or aesthetically pleasing way. We implement several types of familiar graph layout methods, and then given a graph we perform some analysis to attempt to decide which method to perform. We will compare our implemented graph layout methods to similar GraphViz layout programs, and we will show how our display decision process automatically handles a variety of graphs appropriately.

\end{abstract}

\section{Introduction}
Graphs can represent a wide range of data and information, and the task of visualizing graphs is important in revealing the patterns and underlying structure within them. Although many heuristics are available for what determines a "good" visualization such as number of edge crossings, regular spacing, and node overlaps, in the end the best way to visualize a given graph might be circumstantial or domain specific. 
There are subsequently several specialized layout methods that can perform well in particular instances for effective or aesthetic display.
 
Programs such as GraphViz have several different layout methods, but it relys on the user to decide which one to use. 
In other words, the user is required to have an intuition about how each solver works and which one would make their graph appropriately look the best. Instead of saying \textit{how} the graph should be displayed, we would want the user to express that the graph should be displayed.
JumanG seeks to derive which layout method is appropriate by doing some analysis on factors such as the size of the graph, directedness, branching factor, and cyclicity.






JumanG is currently capable of displaying graphs and digraphs as described by the dot language. We developed three different solvers to handle 
a variety of types of graphs and display them both clearly and correctly. JumanG outputs into the TikZ format for LaTeX for easy integration into 
papers like this one.


There are several available tools available for displaying graphs in an attractive and aesthetically pleasing way. 
However, different strategies for displaying the graphs are appropriate at different times depending on the features in the graph. Which 
particular tool to use for any given graph is an exercise left to the user. Our program, JumanG, attempts to take the guesswork out of 
this process and choose the correct display tool for the graph simply by analyzing the properties of the graph, while providing output that 
matches or surpasses the quality provided by the industry standard.


\section{Graph Drawing}


\section{Declarative Pipeline}

We had an Encoder, Solver, and a Decoder

\subsection{The Encoder}
The Dot Parser

\subsection{The Solvers}

\subsubsection{Radial Solver}
Radial displays have been used for some time to display trees of various data in a way different from the typical top-down approach.
Introduced in 1992 by Eades (EADES CITATION), this layout lays the branches out circularly around the root branching outwards, drawing 
nodes at different radii from the center. We implemented our own radial solver that uses slightly different techniques than the original
method. We wrote our solver to evenly distribute nodes around the root at each level, rather than using the traditional style of weighting 
them based on the number of subnodes as is typical for a solver like this. We also chose to display nodes at their closest level to root. 
This allows the solver to draw non-tree graphs fairly well; better, in fact, than Graphviz's twopi on these graphs 
%TODO (INSERT COMPARISON GRAPHS) 
In general, a radial solver is better than a standard layered solver for drawing graphs that are relatively wider than they are deep. Our metric 
for determining whether the radial solver should be used is given by a measure of width: 
$$\frac{number_{nodes}}{depth_{graph}}$$


%TODO add more metanalysis here) (Insert some results here)

In addition to the use as an arrangement for directed graphs, we also found that the radial solver worked as an excellent way to presort nodes for the Springs Solver, because it spreads the nodes out, preventing nodes from clumping together.


\subsubsection{Springs Solver}
%TODO
citation for the springs\cite{springs}


The Springs algorithm, as outlined by (citation), computes a layout for a graph by running a physics simulation on the graph. All of the nodes are set to repel each other, while the edges are set as ``springs" to hold the nodes together. Our solver scales the repelling forces of the nodes based on how densely connected the graphs are, in order to prevent nodes being spaced too close or far apart in the end.

The attraction function between two connected nodes is simply a linear factor of the distance between two nodes. We put in all of these constraints and then simulated the graph interacting with itself for several iterations, attempting to minimize the total energy in the system.

Finally, the solver also requires the nodes to have an initial configuration. 
%TODO citation of book
suggests 2 possible approaches. The first being random placement, where all of the nodes are randomized, and the second being based on geodesic distance. We have implemented both options, and we use the Radial placement algorithm to 


The repulsion force in our Springs Solver:
$$ \frac{(\frac{number_{edges}}{(number_{nodes})^{3}})}{d^2} $$
Where d is the euclidean distance between any two nodes. 



 

In order for these nodes to move freely, however, they must be set to initial positions to react from. (citation of book) suggests 2 possible solutions: 
Random Placement, and a layout based on geodesic distance. We support both options, the second through the radial placement algorithm as mentioned before.
The radial placement works well for graphs with less connections, and gives the nodes good starting points to move from. More highly connected graphs,
however, tend to get stuck in poor positions using this metric, and so for graphs with high connectivity, we default to the random placement. We define 
connectivity as (total nodes / total edges), and we use the randomized solution on graphs with a connectivity higher than (3?).
(insert some example graphs)

\subsubsection{Layered Solver}
Layered graph drawing is an approach to arranging directed acyclic graphs.


\subsubsection{Circo Solver}
Circo is a graph layout solver available from within GraphViz that specializes in arranging circular graphs. 
We use Circo as one of our available graph solvers because we did not implement our own version of a circular layout solver.

%TODO put in an example picture

In our analysis of the given graph, we can determine that a graph is a directed cycle if there are no root nodes, that is nodes that do not have inward edges pointing to them. When a graph is a directed cycle, the Circo Solver tends to have good results. Our Springs Solver does a good job with undirected cycles because the edges ``pull" in both directions, and the balanced forces can properly work on the simulation. 




\subsection{The Decoder}
We decided to output our graphs to TikZ syntax, a package for drawing graphs in LaTeX, which we felt was a very appropriate format, and allowed us to ignore the 
the difficulties of rendering graphics. This also allows us to directly embed our graphs into other LaTeX documents, such as this one. The algorithm for 
writing the graphs is not particularly clever or efficient, and currently we have only one format, but the TikZ package is featureful enough that adding arbitrary
features to the display would not be hard.


\section{Experimental Comparison}


\section{Future Work}


\section{Conclusions}

\bibliographystyle{plain}
\bibliography{citations}




\end{document}
