% Juneki Hong and Michael Tango
% Declarative Methods
% Professor Eisner
% May 3, 2013


\documentclass{article}
\usepackage{acl2012}
\usepackage{times}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{url}
\setlength\titlebox{6.5cm}    % Expanding the titlebox


\title{Declarative Methods Term Project: \\ JumanG}
\author{Juneki Hong and Michael Tango}

%\usepackage[ampersand]{easylist}

\date{}
\begin{document}
\maketitle

\begin{abstract}
In this paper, we attempt to display graphs in an effective or aesthetically pleasing way. We implement several types of familiar graph layout methods, and then given a graph we perform some analysis to attempt to decide which method to perform. We will compare our implemented graph layout methods to similar GraphViz layout programs, and we will show how our display decision process automatically handles a variety of graphs appropriately.

\end{abstract}

\section{Introduction}
Graphs can represent a wide range of data and information, and the task of visualizing graphs is important in revealing the patterns and underlying structure within them. Although many heuristics are available for what determines a "good" visualization such as number of edge crossings, regular spacing, and node overlaps, in the end the best way to visualize a given graph might be circumstantial or domain specific. 
There are subsequently several specialized layout methods that can perform well in particular instances for effective or aesthetic display.
 
Programs such as GraphViz have several different layout methods, but it relys on the user to decide which one to use. 
In other words, the user is required to have an intuition about how each solver works and which one would make their graph appropriately look the best. Instead of saying \textit{how} the graph should be displayed, we would want the user to express that the graph should be displayed.
JumanG seeks to derive which layout method is appropriate by doing some analysis on factors such as the size of the graph, directedness, branching factor, and cyclicity.






JumanG is currently capable of displaying graphs and digraphs as described by the dot language. We developed three different solvers to handle 
a variety of types of graphs and display them both clearly and correctly. JumanG outputs into the TikZ format for LaTeX for easy integration into 
papers like this one.


There are several available tools available for displaying graphs in an attractive and aesthetically pleasing way. 
However, different strategies for displaying the graphs are appropriate at different times depending on the features in the graph. Which 
particular tool to use for any given graph is an exercise left to the user. Our program, JumanG, attempts to take the guesswork out of 
this process and choose the correct display tool for the graph simply by analyzing the properties of the graph, while providing output that 
matches or surpasses the quality provided by the industry standard.


\section{Graph Drawing}


\section{Declarative Pipeline}

We had an Encoder, Solver, and a Decoder

\subsection{The Encoder}
The Dot Parser

\subsection{The Solvers}

\subsubsection{Radial Solver}
Radial displays have been used for some time to display trees of various data in a way different from the typical top-down approach.
Introduced in 1992 by Eades (EADES CITATION), this layout lays the branches out circularly around the root branching outwards, drawing 
nodes at different radii from the center. We implemented our own radial solver that uses slightly different techniques than the original
method. We wrote our solver to evenly distribute nodes around the root at each level, rather than using the traditional style of weighting 
them based on the number of subnodes as is typical for a solver like this. We also chose to display nodes at their closest level to root. 
This allows the solver to draw non-tree graphs fairly well; better, in fact, than Graphviz's twopi on these graphs (INSERT COMPARISON GRAPHS) 
In general, a radial solver is better than a standard layered solver for drawing graphs that are relatively wider than they are deep. Our metric 
for determining whether the radial solver should be used is given by a measure of width, number of nodes / depth of the graph (put in math eq?) (Juneki
add more metanalysis here) (Insert some results here)

In addition to the use as an arrangement for directed graphs, we also found that the radial solver worked as an excellent way to presort nodes for the
Springs Solver, as it spreads the nodes out enough that the nodes resist clumping together.

\subsubsection{Springs Solver}
citation for the springs\cite{springs}
The springs algorithm, as outlined by (citation), computes a layout for a graph by approximating physics; all nodes repel each and every other node, 
and edges act as springs to hold the nodes together. This requires deriving values for these forces, as more highly connected graphs will have 
more edges, and thus more springs, throwing off the balance between the two forces that allows them to be spaced apart. In our solver, we decided
the best way to do this was to hold the spring factor constant and to adjust the repulsion force to generate graphs of desired size. After much 
experimentation, we determined that the equation to describe the force to be (math eq of total number of edges / total number of nodes +2 to the 3 /distance tithe 2)
The spring function was held to simply the distance between the two objects, emulating a spring with a spring constant of 1. We then applied these forces
to the nodes in the graph, keeping the result with the minimum total force in the system.

In order for these nodes to move freely, however, they must be set to initial positions to react from. (citation of book) suggests 2 possible solutions: 
Random Placement, and a layout based on geodesic distance. We support both options, the second through the radial placement algorithm as mentioned before.
The radial placement works well for graphs with less connections, and gives the nodes good starting points to move from. More highly connected graphs,
however, tend to get stuck in poor positions using this metric, and so for graphs with high connectivity, we default to the random placement. We define 
connectivity as (total nodes / total edges), and we use the randomized solution on graphs with a connectivity higher than (3?).
(insert some example graphs)

\subsubsection{Layered Solver}
Layered graph drawing is an approach to arranging directed acyclic graphs.


\subsection{The Decoder}
We decided to output our graphs to TikZ syntax, a package for drawing graphs in LaTeX, which we felt was a very appropriate format, and allowed us to ignore the 
the difficulties of rendering graphics. This also allows us to directly embed our graphs into other LaTeX documents, such as this one. The algorithm for 
writing the graphs is not particularly clever or efficient, and currently we have only one format, but the TikZ package is featureful enough that adding arbitrary
features to the display would not be hard.


\section{Experimental Comparison}


\section{Future Work}


\section{Conclusions}

\bibliographystyle{plain}
\bibliography{citations}




\end{document}
